"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_external_contract_js_1 = require("@tableau/api-external-contract-js");
const api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
const DataSource_1 = require("../../DataSource");
const Field_1 = require("../../Field");
const DataSourceImpl_1 = require("../../Impl/DataSourceImpl");
const FieldImpl_1 = require("../../Impl/FieldImpl");
const TableauError_1 = require("../../TableauError");
const ServiceImplBase_1 = require("./ServiceImplBase");
class DataSourceServiceImpl extends ServiceImplBase_1.ServiceImplBase {
    // Since Object Model is supported since Tableau 2020.2, DataSourceServiceImpl can be initialized with the
    // platform version when OM was supported. Once we drop support for Tableau versions <= 2020.1, all additional
    // code in here for Object Model can be removed.
    constructor(dispatcher, registryId) {
        super(dispatcher, registryId);
    }
    get serviceName() {
        return "data-source-service" /* DataSourceService */;
    }
    refreshAsync(dataSourceId) {
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'refreshAsync',
            [api_internal_contract_js_1.ParameterId.DeltaTimeMs]: 0,
            [api_internal_contract_js_1.ParameterId.ShouldRefreshDS]: true,
        };
        // On server: Not passing the datasource id will refresh all datasources.
        if (dataSourceId) {
            parameters[api_internal_contract_js_1.ParameterId.DataSourceId] = dataSourceId;
        }
        return this.execute(api_internal_contract_js_1.VerbId.RefreshDataSource, parameters).then((response) => {
            return;
        });
    }
    getActiveTablesAsync(dataSourceId) {
        const joinParameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getActiveTablesAsync',
            [api_internal_contract_js_1.ParameterId.DataSourceId]: dataSourceId,
        };
        // Get the description of the tables used by this connection
        return this.execute(api_internal_contract_js_1.VerbId.GetActiveTables, joinParameters).then((joinResponse) => {
            const tableInfos = joinResponse.result;
            // getActiveTables is unsupported for cubes and GA. We do not have a connection type property
            // available from the platform (intentionally, to reduce code churn as new connections are added).
            // Instead,just check if any tables are returned. This array will be empty for any non-table based datasource.
            if (tableInfos.tables.length === 0) {
                throw new TableauError_1.TableauError(api_external_contract_js_1.ErrorCodes.UnsupportedMethodForDataSourceType, `getActiveTables is not supported for: ${dataSourceId}`);
            }
            return tableInfos.tables;
        });
    }
    getDataSourcesAsync(visualId) {
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getDataSourcesAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
        };
        return this.execute(api_internal_contract_js_1.VerbId.GetDataSources, parameters).then((response) => {
            const dataSchema = response.result;
            return dataSchema;
        });
    }
    getAllDataSourcesAsync() {
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getAllDataSourcesAsync',
        };
        return this.execute(api_internal_contract_js_1.VerbId.GetAllDataSources, parameters).then((response) => {
            const dataSchema = response.result;
            return dataSchema;
        });
    }
    getConnectionSummariesAsync(dataSourceId) {
        const params = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getConnectionSummariesAsync',
            [api_internal_contract_js_1.ParameterId.DataSourceId]: dataSourceId,
        };
        // Get the description of the tables used by this connection
        return this.execute(api_internal_contract_js_1.VerbId.GetConnectionDescriptionSummaries, params).then((response) => {
            const descriptionSummaries = response.result;
            return descriptionSummaries;
        });
    }
    getFieldAsync(globalfieldName) {
        const verb = api_internal_contract_js_1.VerbId.GetFieldAndDataSource;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getFieldAsync',
            [api_internal_contract_js_1.ParameterId.FieldId]: globalfieldName,
        };
        return this.execute(verb, parameters).then((response) => {
            const dataSource = response.result[api_internal_contract_js_1.ParameterId.DataSource];
            const field = response.result[api_internal_contract_js_1.ParameterId.Field];
            return this.convertField(field, this.convertDataSource(dataSource));
        });
    }
    getLogicalTablesAsync(dataSourceId) {
        const params = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getLogicalTablesAsync',
            [api_internal_contract_js_1.ParameterId.DataSourceId]: dataSourceId,
        };
        return this.execute(api_internal_contract_js_1.VerbId.GetLogicalTables, params).then((response) => {
            return response.result;
        });
    }
    getUnderlyingTablesAsync(visualId) {
        const params = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getUnderlyingTablesAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
        };
        return this.execute(api_internal_contract_js_1.VerbId.GetUnderlyingTables, params).then((response) => {
            return response.result;
        });
    }
    convertField(field, dataSource) {
        return new Field_1.Field(new FieldImpl_1.FieldImpl(field, dataSource));
    }
    convertDataSource(dataSource) {
        return new DataSource_1.DataSource(new DataSourceImpl_1.DataSourceImpl(dataSource, this._registryId));
    }
}
exports.DataSourceServiceImpl = DataSourceServiceImpl;
//# sourceMappingURL=DataSourceServiceImpl.js.map