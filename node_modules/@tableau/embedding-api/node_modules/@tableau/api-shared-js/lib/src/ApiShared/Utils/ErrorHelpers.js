"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_external_contract_js_1 = require("@tableau/api-external-contract-js");
const TableauError_1 = require("../TableauError");
const Param_1 = require("./Param");
/**
 * This class is used to construct common errors throughout the external
 * projects (api-shared, extensions-api, etc.).  It has some duplication with
 * the ErrorHelpers class in api-core, but is separate due to the need to throw
 * an external TableauError vs. an InternalTableauError.
 */
class ErrorHelpers {
    /**
     * Throws with code InternalError.
     *
     * @param apiName name of api that was called.
     */
    static apiNotImplemented(apiName) {
        return new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InternalError, `${apiName} API not yet implemented.`);
    }
    /**
     * Throws an internal error if argument is null or undefined.
     *
     * @param argumentValue value to verify
     * @param argumentName name of argument to verify
     */
    /*tslint:disable-next-line */
    static verifyInternalValue(argumentValue, argumentName) {
        if (argumentValue === null || argumentValue === undefined) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InternalError, `${argumentValue} is invalid value for: ${argumentName}`);
        }
    }
    /**
     * Throws an InvalidParameter error if argument is null or undefined.
     *
     * @param argumentValue value to verify
     * @param argumentName name of argument to verify
     */
    /*tslint:disable-next-line */
    static verifyParameter(argumentValue, argumentName) {
        if (argumentValue === null || argumentValue === undefined) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `${argumentValue} is invalid value for parameter: ${argumentName}`);
        }
    }
    /**
     * Throws an InvalidParameter error if argument is not the specified type.
     * For objects, it just tests that it is an object
     *
     * @param argumentValue value to verify
     * @param expectedType expected result of typeof
     * @param argumentName name of argument to verify
     */
    /*tslint:disable-next-line */
    static verifyParameterType(argumentValue, expectedType, argumentName) {
        if (typeof argumentValue !== expectedType) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `${argumentValue} has invalid type for parameter: ${argumentName}.`);
        }
    }
    /**
     * Throws an InvalidParameter error if argument is empty string, null or undefined.
     *
     * @param argumentValue value to verify
     * @param argumentName name of argument to verify
     */
    /*tslint:disable-next-line */
    static verifyStringParameter(argumentValue, argumentName) {
        if (argumentValue === null || argumentValue === undefined || argumentValue === '') {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `${argumentValue} is invalid value for paramter: ${argumentName}`);
        }
    }
    /**
     * Verifies passed value is a valid value for that enum.
     *
     * String enums are {string : string} dictionaries which are not reverse mappable
     * This is an ugly workaround
     *
     * @param enumValue value to verify
     * @param enumType enum to verify against
     */
    /*tslint:disable-next-line */
    static isValidEnumValue(enumValue, enumType) {
        let isValid = false;
        Object.keys(enumType).forEach((enumKey) => {
            if (enumType[enumKey] === enumValue.toString()) {
                isValid = true;
            }
        });
        return isValid;
    }
    /**
     * Verifies passed value is a valid value for that enum.
     * Throws an InvalidParameter error if the enum value is not valid.
     *
     * String enums are {string : string} dictionaries which are not reverse mappable
     * This is an ugly workaround
     *
     * @param enumValue value to verify
     * @param enumType enum to verify against
     * @param enumName enum name for clear error message
     */
    /*tslint:disable-next-line */
    static verifyEnumValue(enumValue, enumType, enumName) {
        if (!ErrorHelpers.isValidEnumValue(enumValue, enumType)) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `${enumValue} is invalid value for enum: ${enumName}.`);
        }
    }
    /**
     * Verifies passed value is between [min, max) ... min <= value < max
     * Throws an InvalidParameter error if the value is not valid.
     *
     *
     * @param value value to verify
     * @param min   value must be >= min
     * @param max   value must be < max
     */
    static verifyRange(value, min, max) {
        let isValid = min <= value && value < max;
        if (!isValid) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `${value} is invalid value for range: [${min}..${max})`);
        }
    }
    /**
     * Verifies the params min and max for applying range filter.
     * Throws with error code InvalidParameter if range is invalid.
     *
     * @param min range min
     * @param max range max
     */
    static verifyRangeParamType(min, max) {
        const isMinDefined = min !== undefined;
        const isMaxDefined = max !== undefined;
        if (!isMinDefined && !isMaxDefined) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'Unexpected invalid param value, at least one of min or max is required.');
        }
        if (isMinDefined && !Param_1.Param.isTypeNumber(min) && !Param_1.Param.isTypeDate(min)) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'Unexpected invalid param value, only Date and number are allowed for parameter min.');
        }
        if (isMaxDefined && !Param_1.Param.isTypeNumber(max) && !Param_1.Param.isTypeDate(max)) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'Unexpected invalid param value, only Date and number are allowed for parameter max.');
        }
        if (isMinDefined && isMaxDefined && typeof min !== typeof max) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'Unexpected invalid param value, parameters min and max should be of the same type.');
        }
    }
    /**
     * Verifies that the zoneId is present in the current dashboard.
     * Throws with error code InvalidParameter if either condition is false.
     *
     * @param dashboardZoneMap A map of zoneId's to the corresponding dashboard object.
     * @param zoneID ZoneId to be validated
     */
    static verifyZoneIsValid(dashboardZoneMap, zoneID) {
        if (dashboardZoneMap.has(zoneID)) {
            return;
        }
        throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `Unexpected invalid param value, Dashboard Object Id: ${zoneID} is not present in dashboard.`);
    }
    /**
     * Verifies that the zone is present and floating in the current dashboard.
     * Throws with error code InvalidParameter if either condition is false.
     *
     * @param dashboardZoneMap A map of zoneId's to the corresponding dashboard object.
     * @param zoneID ZoneId to be validated
     */
    static verifyZoneIsValidAndFloating(dashboardZoneMap, zoneID) {
        if (dashboardZoneMap.has(zoneID) && dashboardZoneMap.get(zoneID).isFloating) {
            return;
        }
        throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `Unexpected invalid param value, Dashboard Object Id: ${zoneID} is not present or is a fixed zone in the dashboard.`);
    }
    /**
     * Verifies that width and height are > 0 for each DashboardObjectPositionAndSizeUpdate object.
     * Throws with error code InvalidParameter if either condition is false.
     *
     * @param dashboardObjectPositionAndSizeUpdate DashboardObjectPositionAndSizeUpdate object for which width and height will be validated
     */
    static verifyWidthAndHeightOfDashboardObjectPositionAndSizeUpdate(dashboardObjectPositionAndSizeUpdate) {
        if (dashboardObjectPositionAndSizeUpdate.width < 0 || dashboardObjectPositionAndSizeUpdate.height < 0) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, `Unexpected invalid param value for dashboard object ID ${dashboardObjectPositionAndSizeUpdate.dashboardObjectID}:` +
                ` negative widths and heights are not allowed.`);
        }
    }
    /**
     * Verifies is the given sheet name is in the list of sheets names allowed for exporting.
     * Throws with error code InvalidParameter if the condition above is false.
     *
     * @param exportableSheetNames A list of sheet names allowed for exporting
     * @param sheetName the name of the sheet selected for export
     */
    static verifySheetName(exportableSheetNames, sheetName) {
        if (!exportableSheetNames.includes(sheetName)) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidSelectionSheet, 'sheetName parameter must belong to a worksheet within the current view');
        }
    }
    /**
     * Verifies the ExportDataOptions object
     * Throws with error code InvalidParameter if the parameter is not of ExportDataOptions type.
     *
     * @param options The ExportDataOptions object used to configure the output CSV file for exportDataAsync.
     */
    static verifyExportDataOptions(options) {
        if ((!Param_1.Param.isNullOrUndefined(options.ignoreAliases) && !Param_1.Param.isTypeBool(options.ignoreAliases)) ||
            (!Param_1.Param.isNullOrUndefined(options.columnsToIncludeById) && !Array.isArray(options.columnsToIncludeById)))
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'options paramater must be of type ExportDataOptions');
    }
    /**
     * Verifies if the sheet names are included in any of the export scenarios.
     * Throws with error code InvalidParameter if the parameter is not an array.
     * Throws with error code InvalidSelectionSheet if there are array entries that dont exist or if there is mixing between sheets from the dashboard and sheet from the workbook.
     *
     * @param sheetNames List of sheet names selected for exporting.
     * @param exportScenarios an object containing the current sheet name, exportable sheets from the dashboard, and exportable sheets from the workbook.
     */
    static verifySheetNamesForPDFAndPPT(sheetNames, exportScenarios) {
        if (!Array.isArray(sheetNames))
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'sheetNames parameter must be an array');
        if (sheetNames.length === 0)
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InternalError, 'sheetNames should not be empty');
        const isIncludedInDashboard = sheetNames.every((sheetName) => exportScenarios.exportableSheetNamesFromDashboard.includes(sheetName));
        if (isIncludedInDashboard) {
            return;
        }
        const isIncludedInWorkbook = sheetNames.every((sheetName) => exportScenarios.exportableSheetNamesFromWorkbook.includes(sheetName));
        if (isIncludedInWorkbook) {
            return;
        }
        const isCurrentSheet = sheetNames.length === 1 && sheetNames[0] === exportScenarios.currentSheetName;
        if (isCurrentSheet) {
            return;
        }
        // Export requirement: all sheet names must be included in the list of exportable sheets in the dashboard or
        // all sheet names must be included in the list of exportable sheets in the workbook, or the sheet name is the current sheet
        throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidSelectionSheet, 'sheetNames parameter must have all its entries be exportable sheet names from the dashboard or all its entries be exportable sheet names from the workbook');
    }
    /**
     * Verifies the external ExportPDFOptions object's properties.
     * Throws with error code InvalidParameter if the parameter is not of external ExportPDFOptions type.
     *
     * @param options The external user-facing ExportPDFOptions object used to configure the output PDF file for exportPDFAsync.
     */
    static verifyExportPDFOptions(options) {
        try {
            this.verifyEnumValue(options.orientation, api_external_contract_js_1.PrintOrientation, 'PrintOrientation');
            this.verifyEnumValue(options.pageSize, api_external_contract_js_1.PrintPageSize, 'PrintPageSize');
            this.verifyEnumValue(options.scaling, api_external_contract_js_1.PrintScaling, 'PrintScaling');
        }
        catch (_a) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InvalidParameter, 'options parameter must be of type ExportPDFOptions');
        }
    }
}
exports.ErrorHelpers = ErrorHelpers;
//# sourceMappingURL=ErrorHelpers.js.map