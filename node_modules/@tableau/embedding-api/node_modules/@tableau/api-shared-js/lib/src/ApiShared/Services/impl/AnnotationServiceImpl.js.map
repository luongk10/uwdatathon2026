{"version":3,"file":"AnnotationServiceImpl.js","sourceRoot":"","sources":["../../../../../src/ApiShared/Services/impl/AnnotationServiceImpl.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Contract from '@tableau/api-external-contract-js';\nimport { AnnotateEnum, Annotation, ExecuteParameters, ParameterId, VerbId, VisualId } from '@tableau/api-internal-contract-js';\nimport { InternalToExternalEnumMappings } from '../../EnumMappings/InternalToExternalEnumMappings';\nimport { SelectionModelsContainer, TupleSelectionModel } from '../../Models/SelectionModels';\nimport { TableauError } from '../../TableauError';\nimport { AnnotationService } from '../AnnotationService';\nimport { ServiceNames } from '../ServiceRegistry';\nimport { ServiceImplBase } from './ServiceImplBase';\n\nexport class AnnotationServiceImpl extends ServiceImplBase implements AnnotationService {\n  public get serviceName(): string {\n    return ServiceNames.Annotation;\n  }\n\n  /**\n   * Method to annotate a mark on the given worksheet.\n   *\n   * @param visualId\n   * @param mark\n   * @param annotationText\n   */\n  public annotateMarkAsync(visualId: VisualId, mark: Contract.MarkInfo, annotationText: string): Promise<void> {\n    const selectionModelContainer: SelectionModelsContainer = this.parseMarkSelectionIds([mark]);\n    const dummyTargetPoint = { x: 0, y: 0 };\n    const formattedText = `<formatted-text><run>${annotationText}</run></formatted-text>`;\n\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'annotateMarkAsync',\n      [ParameterId.VisualId]: visualId,\n      [ParameterId.AnnotateEnum]: AnnotateEnum.Mark,\n      [ParameterId.TargetPoint]: dummyTargetPoint,\n      [ParameterId.SelectionList]: [selectionModelContainer.selection],\n      [ParameterId.FormattedText]: formattedText,\n    };\n    return this.execute(VerbId.CreateAnnotation, parameters).then<void>((response) => {\n      // Expecting an empty model and hence the void response.\n      return;\n    });\n  }\n\n  /**\n   * Method to retrieve annotations for the given worksheet.\n   *\n   * @param visualId\n   * @returns {Promise<Array<Annotation>>}\n   */\n  public getAnnotationsAsync(visualId: VisualId): Promise<Array<Contract.Annotation>> {\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'getAnnotationsAsync',\n      [ParameterId.VisualId]: visualId,\n    };\n    return this.execute(VerbId.GetAnnotations, parameters).then<Array<Contract.Annotation>>((response) => {\n      const annotationsList = response.result as Array<Annotation>;\n      return this.annotationFilterMap(annotationsList);\n    });\n  }\n\n  /**\n   * Method to remove an annotation from a given worksheet.\n   *\n   * @param visualId\n   * @param annotation\n   */\n  public removeAnnotationAsync(visualId: VisualId, annotation: Contract.Annotation): Promise<void> {\n    const selectionModelContainer: SelectionModelsContainer = this.parseAnnotationSelectionIds([annotation]);\n\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'removeAnnotationAsync',\n      [ParameterId.VisualId]: visualId,\n      [ParameterId.SelectionList]: [selectionModelContainer.selection],\n    };\n    return this.execute(VerbId.RemoveAnnotation, parameters).then<void>((response) => {\n      // Expecting an empty model and hence the void response.\n      return;\n    });\n  }\n\n  /**\n   * Method to prepare the pres models for selection by MarksInfo\n   * @param marks\n   */\n  private parseMarkSelectionIds(marks: Array<Contract.MarkInfo>): SelectionModelsContainer {\n    const ids: Array<string> = [];\n    const selectionModelContainer: SelectionModelsContainer = new SelectionModelsContainer();\n    marks.forEach((mark) => {\n      const tupleId: number | undefined = mark.tupleId;\n      if (tupleId !== undefined && tupleId !== null && tupleId > 0) {\n        ids.push(tupleId.toString()); // collect the tuple ids\n      } else {\n        throw new TableauError(Contract.ErrorCodes.InternalError, 'invalid tupleId');\n      }\n    });\n    if (ids.length !== 0) {\n      // tuple ids based selection\n      const tupleSelectionModel: TupleSelectionModel = new TupleSelectionModel();\n      tupleSelectionModel.selectionType = 'tuples';\n      tupleSelectionModel.objectIds = ids;\n      selectionModelContainer.selection = tupleSelectionModel;\n    }\n    return selectionModelContainer;\n  }\n\n  /**\n   * Method to prepare the pres models for selection by MarkAnnotationInfo\n   * @param marks\n   */\n  private parseAnnotationSelectionIds(annotations: Array<Contract.Annotation>): SelectionModelsContainer {\n    const ids: Array<string> = [];\n    const selectionModelContainer: SelectionModelsContainer = new SelectionModelsContainer();\n    annotations.forEach((annotation) => {\n      const annotationId: number | undefined = annotation.annotationId;\n      if (annotationId !== undefined && annotationId !== null && annotationId >= 0) {\n        ids.push(annotationId.toString()); // collect the annotation ids\n      } else {\n        throw new TableauError(Contract.ErrorCodes.InternalError, 'invalid annotationId');\n      }\n    });\n    if (ids.length !== 0) {\n      // annotation ids based selection\n      const tupleSelectionModel: TupleSelectionModel = new TupleSelectionModel();\n      tupleSelectionModel.selectionType = 'annotations';\n      tupleSelectionModel.objectIds = ids;\n      selectionModelContainer.selection = tupleSelectionModel;\n    }\n    return selectionModelContainer;\n  }\n\n  /**\n   * Method to map Annotation to MarkAnnotationInfo\n   * @param annotation\n   * @returns {Annotation}\n   */\n  private mapAnnotation(annotation: Annotation): Contract.Annotation {\n    return {\n      annotationHTML: annotation.annotationText,\n      annotationId: annotation.annotationId,\n      annotationText: annotation.annotationPlainText,\n      annotationType: InternalToExternalEnumMappings.annotationType.convert(annotation.annotateEnum),\n      tupleId: annotation.tupleId!,\n    };\n  }\n\n  /**\n   * Filter the Annotations to Mark Annotations, and map them to MarkAnnotationInfo\n   * @param annotations\n   * @returns {Array<Annotation>}\n   */\n  private annotationFilterMap(annotations: Array<Annotation>): Array<Contract.Annotation> {\n    const annotationInfos = annotations.map((annotation) => this.mapAnnotation(annotation));\n\n    return annotationInfos;\n  }\n}\n"]}