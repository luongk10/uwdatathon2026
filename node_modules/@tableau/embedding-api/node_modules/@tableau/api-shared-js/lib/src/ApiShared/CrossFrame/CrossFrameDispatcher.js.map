{"version":3,"file":"CrossFrameDispatcher.js","sourceRoot":"","sources":["../../../../src/ApiShared/CrossFrame/CrossFrameDispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { EmbeddingErrorCodes } from '@tableau/api-external-contract-js';\nimport {\n  CommandResponseMessage,\n  ExecuteParameters,\n  ExecuteResponse,\n  InternalApiDispatcher,\n  Messenger,\n  Model,\n  NotificationHandler,\n  NotificationMessage,\n  VerbId,\n} from '@tableau/api-internal-contract-js';\nimport { TableauError } from '../TableauError';\n\n/**\n * This is an implementation of the InternalApiDispatcher interface which functions by passing messages\n * across a frame boundary. This is usually between the code where our javscript library has been included\n * by a 3rd party dev and another frame where Tableau server has content.\n */\nexport class CrossFrameDispatcher implements InternalApiDispatcher {\n  // Collection of pending promises which are waiting to be resolved. When we receive a response back from the other frame,\n  // these promises can be either resolved or rejected\n  private _pendingPromises: { [messageGuid: string]: { resolve: (response: ExecuteResponse) => void; reject: (error: Model) => void } } =\n    {};\n\n  // The collection of notification handlers which have been registered with this dispatcher\n  private _notificationHandlers: Array<NotificationHandler> = [];\n\n  /**\n   * Creates an instance of CrossFrameDispatcher which will use the given messenger to communicate\n   * @param _messenger an instantiated and listening messenger object\n   */\n  public constructor(private _messenger: Messenger) {\n    if (!this._messenger) {\n      throw 'Missing messenger object';\n    }\n\n    // Set up our message handlers. We only care about incoming notifications and command responses\n    this._messenger.setCommandResponseMessageHandler(this.onCommandResponse.bind(this));\n    this._messenger.setNotificationMessageHandler(this.onNotification.bind(this));\n  }\n\n  ////// Start InternalApiDispatcher implementation\n\n  public execute(verb: VerbId, parameters: ExecuteParameters): Promise<ExecuteResponse> {\n    // To execute a verb, we first prepare a command message and then define a promise.\n    const preparedMessage = this._messenger.prepareCommandMessage(verb, parameters);\n    const promise = new Promise<ExecuteResponse>((resolve, reject) => {\n      // Save off the pending promise by the messageGuid we are about to send. When a response is\n      // received, we'll be able to resolve this promise with the result\n      this._pendingPromises[preparedMessage.messageGuid] = { resolve: resolve, reject: reject };\n    });\n\n    // Actually send the message and return the promise\n    preparedMessage.send();\n    return promise;\n  }\n\n  public registerNotificationHandler(handler: NotificationHandler): void {\n    this._notificationHandlers.push(handler);\n  }\n\n  public unregisterNotificationHandler(handler: NotificationHandler): void {\n    this._notificationHandlers = this._notificationHandlers.filter((h) => h !== handler);\n  }\n\n  ////// End InternalApiDispatcher implementation\n\n  private onCommandResponse(response: CommandResponseMessage): void {\n    // We got a command response, look through the pending promises and resolve\n    if (Object.keys(this._pendingPromises).indexOf(response.commandGuid) < 0) {\n      return; // We don't have any reference to this command, just return\n    }\n\n    const pendingPromise = this._pendingPromises[response.commandGuid];\n\n    // If we have an error defined, reject the promise\n    if (response.error) {\n      pendingPromise.reject(response.error);\n    }\n\n    // If we have data defined, resolve the promise\n    if (response.data) {\n      pendingPromise.resolve({ result: response.data });\n    }\n\n    // Clean up our pending promises object\n    delete this._pendingPromises[response.commandGuid];\n  }\n\n  private onNotification(notificationMessage: NotificationMessage): void {\n    // Go through each notification handler we have registered and let them know a notification came in\n    for (const handler of this._notificationHandlers) {\n      try {\n        handler({ notificationId: notificationMessage.notificationId, data: notificationMessage.data });\n      } catch (e) {\n        // Incase of a IncompatibleVersionError, re-throw the error.\n        if ((e as TableauError).errorCode === EmbeddingErrorCodes.IncompatibleVersionError) {\n          throw e;\n        }\n        // Else Ignore  so if one handler errors, the other still get the message.\n      }\n    }\n  }\n}\n"]}