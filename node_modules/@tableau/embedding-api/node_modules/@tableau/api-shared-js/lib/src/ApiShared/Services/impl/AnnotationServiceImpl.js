"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Contract = require("@tableau/api-external-contract-js");
const api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
const InternalToExternalEnumMappings_1 = require("../../EnumMappings/InternalToExternalEnumMappings");
const SelectionModels_1 = require("../../Models/SelectionModels");
const TableauError_1 = require("../../TableauError");
const ServiceImplBase_1 = require("./ServiceImplBase");
class AnnotationServiceImpl extends ServiceImplBase_1.ServiceImplBase {
    get serviceName() {
        return "annotation-service" /* Annotation */;
    }
    /**
     * Method to annotate a mark on the given worksheet.
     *
     * @param visualId
     * @param mark
     * @param annotationText
     */
    annotateMarkAsync(visualId, mark, annotationText) {
        const selectionModelContainer = this.parseMarkSelectionIds([mark]);
        const dummyTargetPoint = { x: 0, y: 0 };
        const formattedText = `<formatted-text><run>${annotationText}</run></formatted-text>`;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'annotateMarkAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
            [api_internal_contract_js_1.ParameterId.AnnotateEnum]: api_internal_contract_js_1.AnnotateEnum.Mark,
            [api_internal_contract_js_1.ParameterId.TargetPoint]: dummyTargetPoint,
            [api_internal_contract_js_1.ParameterId.SelectionList]: [selectionModelContainer.selection],
            [api_internal_contract_js_1.ParameterId.FormattedText]: formattedText,
        };
        return this.execute(api_internal_contract_js_1.VerbId.CreateAnnotation, parameters).then((response) => {
            // Expecting an empty model and hence the void response.
            return;
        });
    }
    /**
     * Method to retrieve annotations for the given worksheet.
     *
     * @param visualId
     * @returns {Promise<Array<Annotation>>}
     */
    getAnnotationsAsync(visualId) {
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getAnnotationsAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
        };
        return this.execute(api_internal_contract_js_1.VerbId.GetAnnotations, parameters).then((response) => {
            const annotationsList = response.result;
            return this.annotationFilterMap(annotationsList);
        });
    }
    /**
     * Method to remove an annotation from a given worksheet.
     *
     * @param visualId
     * @param annotation
     */
    removeAnnotationAsync(visualId, annotation) {
        const selectionModelContainer = this.parseAnnotationSelectionIds([annotation]);
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'removeAnnotationAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
            [api_internal_contract_js_1.ParameterId.SelectionList]: [selectionModelContainer.selection],
        };
        return this.execute(api_internal_contract_js_1.VerbId.RemoveAnnotation, parameters).then((response) => {
            // Expecting an empty model and hence the void response.
            return;
        });
    }
    /**
     * Method to prepare the pres models for selection by MarksInfo
     * @param marks
     */
    parseMarkSelectionIds(marks) {
        const ids = [];
        const selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        marks.forEach((mark) => {
            const tupleId = mark.tupleId;
            if (tupleId !== undefined && tupleId !== null && tupleId > 0) {
                ids.push(tupleId.toString()); // collect the tuple ids
            }
            else {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'invalid tupleId');
            }
        });
        if (ids.length !== 0) {
            // tuple ids based selection
            const tupleSelectionModel = new SelectionModels_1.TupleSelectionModel();
            tupleSelectionModel.selectionType = 'tuples';
            tupleSelectionModel.objectIds = ids;
            selectionModelContainer.selection = tupleSelectionModel;
        }
        return selectionModelContainer;
    }
    /**
     * Method to prepare the pres models for selection by MarkAnnotationInfo
     * @param marks
     */
    parseAnnotationSelectionIds(annotations) {
        const ids = [];
        const selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        annotations.forEach((annotation) => {
            const annotationId = annotation.annotationId;
            if (annotationId !== undefined && annotationId !== null && annotationId >= 0) {
                ids.push(annotationId.toString()); // collect the annotation ids
            }
            else {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'invalid annotationId');
            }
        });
        if (ids.length !== 0) {
            // annotation ids based selection
            const tupleSelectionModel = new SelectionModels_1.TupleSelectionModel();
            tupleSelectionModel.selectionType = 'annotations';
            tupleSelectionModel.objectIds = ids;
            selectionModelContainer.selection = tupleSelectionModel;
        }
        return selectionModelContainer;
    }
    /**
     * Method to map Annotation to MarkAnnotationInfo
     * @param annotation
     * @returns {Annotation}
     */
    mapAnnotation(annotation) {
        return {
            annotationHTML: annotation.annotationText,
            annotationId: annotation.annotationId,
            annotationText: annotation.annotationPlainText,
            annotationType: InternalToExternalEnumMappings_1.InternalToExternalEnumMappings.annotationType.convert(annotation.annotateEnum),
            tupleId: annotation.tupleId,
        };
    }
    /**
     * Filter the Annotations to Mark Annotations, and map them to MarkAnnotationInfo
     * @param annotations
     * @returns {Array<Annotation>}
     */
    annotationFilterMap(annotations) {
        const annotationInfos = annotations.map((annotation) => this.mapAnnotation(annotation));
        return annotationInfos;
    }
}
exports.AnnotationServiceImpl = AnnotationServiceImpl;
//# sourceMappingURL=AnnotationServiceImpl.js.map