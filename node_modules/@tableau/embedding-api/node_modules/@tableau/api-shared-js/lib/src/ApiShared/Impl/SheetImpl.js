"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Contract = require("@tableau/api-external-contract-js");
const ServiceRegistry_1 = require("../Services/ServiceRegistry");
const TableauError_1 = require("../TableauError");
const ErrorHelpers_1 = require("../Utils/ErrorHelpers");
const Param_1 = require("../Utils/Param");
const SheetUtils_1 = require("../Utils/SheetUtils");
class SheetImpl {
    constructor(_sheetInfoImpl, _registryId) {
        this._sheetInfoImpl = _sheetInfoImpl;
        this._registryId = _registryId;
    }
    get name() {
        return this._sheetInfoImpl.name;
    }
    get sheetType() {
        return this._sheetInfoImpl.sheetType;
    }
    get sheetPath() {
        return this._sheetInfoImpl.sheetPath;
    }
    get size() {
        return this._sheetInfoImpl.sheetSize;
    }
    get hidden() {
        if (this._sheetInfoImpl.isHidden !== undefined) {
            return this._sheetInfoImpl.isHidden;
        }
        throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.ImplementationError, `isHidden not implemented`);
    }
    get active() {
        if (this._sheetInfoImpl.isActive !== undefined) {
            return this._sheetInfoImpl.isActive;
        }
        throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.ImplementationError, `active not implemented`);
    }
    set active(active) {
        if (this._sheetInfoImpl.isActive !== undefined) {
            this._sheetInfoImpl.active = active;
        }
    }
    get index() {
        if (this._sheetInfoImpl.index !== undefined) {
            return this._sheetInfoImpl.index;
        }
        throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.ImplementationError, `index not implemented`);
    }
    get url() {
        if (this._sheetInfoImpl.url !== undefined) {
            return this._sheetInfoImpl.url;
        }
        throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.ImplementationError, `url not implemented`);
    }
    getSheetSize() {
        if (!SheetUtils_1.SheetUtils.isValidSheetSize(this.size)) {
            throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InternalError, 'size is not of type SheetSize');
        }
        return this.size;
    }
    findParameterAsync(parameterName) {
        ErrorHelpers_1.ErrorHelpers.verifyParameter(parameterName, 'parameterName');
        const service = ServiceRegistry_1.ApiServiceRegistry.get(this._registryId).getService("parameters-service" /* Parameters */);
        return service.findParameterByNameAsync(parameterName);
    }
    getParametersAsync() {
        const service = ServiceRegistry_1.ApiServiceRegistry.get(this._registryId).getService("parameters-service" /* Parameters */);
        return service.getParametersForSheetAsync(this.sheetPath);
    }
    changeSizeAsync(newSize) {
        const invalidSizeError = new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Invalid sheet size parameter');
        if (!newSize || !newSize.behavior) {
            throw invalidSizeError;
        }
        const partialSheetSize = this.normalizeSheetSize(newSize);
        const isAutomatic = partialSheetSize.behavior === Contract.SheetSizeBehavior.Automatic;
        if (!isAutomatic && !partialSheetSize.minSize && !partialSheetSize.maxSize) {
            throw invalidSizeError;
        }
        if (!isAutomatic && this.sheetType === Contract.SheetType.Worksheet) {
            throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSizeBehaviorOnWorksheet, 'Only SheetSizeBehavior.Automatic is allowed on Worksheets');
        }
        if (isAutomatic && this.getSheetSize().behavior === partialSheetSize.behavior) {
            return Promise.resolve(newSize);
        }
        const processedNewSize = this.processNewSize(partialSheetSize);
        const sizeService = ServiceRegistry_1.ApiServiceRegistry.get(this._registryId).getService("size-service" /* Size */);
        return sizeService.changeSizeAsync(this.name, processedNewSize).then(() => {
            const clientInfoService = ServiceRegistry_1.ApiServiceRegistry.get(this._registryId).getService("client-info-service" /* ClientInfo */);
            return clientInfoService.getClientInfoAsync().then((bootstrapInfo) => {
                const sheet = bootstrapInfo.publishedSheets.find((s) => s.name === this.name);
                if (!sheet) {
                    throw new TableauError_1.TableauError(Contract.SharedErrorCodes.InternalError, `Can't find sheet with name ${this.name}`);
                }
                const sheetSize = SheetUtils_1.SheetUtils.getSheetSizeFromSizeConstraints(sheet.sizeConstraint);
                this._sheetInfoImpl.sheetSize = sheetSize;
                return sheetSize;
            });
        });
    }
    normalizeSheetSize(newSize) {
        const { behavior } = newSize;
        ErrorHelpers_1.ErrorHelpers.verifyEnumValue(behavior, Contract.SheetSizeBehavior, 'SheetSizeBehavior');
        const minSize = SheetImpl.parseDimensions(newSize.minSize);
        const maxSize = SheetImpl.parseDimensions(newSize.maxSize);
        return { behavior, minSize, maxSize };
    }
    processNewSize(newSize) {
        var _a, _b, _c, _d;
        const { behavior, minSize: minSizeMaybe, maxSize: maxSizeMaybe } = newSize;
        const hasMinWidth = !Param_1.Param.isNullOrUndefined((_a = minSizeMaybe) === null || _a === void 0 ? void 0 : _a.width);
        const hasMinHeight = !Param_1.Param.isNullOrUndefined((_b = minSizeMaybe) === null || _b === void 0 ? void 0 : _b.height);
        const hasMaxWidth = !Param_1.Param.isNullOrUndefined((_c = maxSizeMaybe) === null || _c === void 0 ? void 0 : _c.width);
        const hasMaxHeight = !Param_1.Param.isNullOrUndefined((_d = maxSizeMaybe) === null || _d === void 0 ? void 0 : _d.height);
        const hasValidMinSize = hasMinWidth && hasMinHeight;
        const hasValidMaxSize = hasMaxWidth && hasMaxHeight;
        switch (behavior) {
            case Contract.SheetSizeBehavior.Automatic: {
                return { behavior };
            }
            case Contract.SheetSizeBehavior.AtMost: {
                if (!maxSizeMaybe || !hasValidMaxSize) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.MissingMaxSize, 'Missing maxSize for SheetSizeBehavior.AtMost');
                }
                const maxSize = { width: maxSizeMaybe.width, height: maxSizeMaybe.height };
                if (maxSize.width < 0 || maxSize.height < 0) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Size value cannot be less than zero');
                }
                return { behavior, maxSize };
            }
            case Contract.SheetSizeBehavior.AtLeast: {
                if (!minSizeMaybe || !hasValidMinSize) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.MissingMinSize, 'Missing minSize for SheetSizeBehavior.AtLeast');
                }
                const minSize = { width: minSizeMaybe.width, height: minSizeMaybe.height };
                if (minSize.width < 0 || minSize.height < 0) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Size value cannot be less than zero');
                }
                return { behavior, minSize };
            }
            case Contract.SheetSizeBehavior.Range: {
                if (!minSizeMaybe || !maxSizeMaybe || !hasValidMinSize || !hasValidMaxSize) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.MissingMinMaxSize, 'Missing minSize or maxSize for SheetSizeBehavior.Range');
                }
                const minSize = { width: minSizeMaybe.width, height: minSizeMaybe.height };
                const maxSize = { width: maxSizeMaybe.width, height: maxSizeMaybe.height };
                if (minSize.width < 0 ||
                    minSize.height < 0 ||
                    maxSize.width < 0 ||
                    maxSize.height < 0 ||
                    minSize.width > maxSize.width ||
                    minSize.height > maxSize.height) {
                    throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Missing minSize or maxSize for SheetSizeBehavior.Range');
                }
                return { behavior, minSize, maxSize };
            }
            case Contract.SheetSizeBehavior.Exactly: {
                if (minSizeMaybe && maxSizeMaybe) {
                    if (hasValidMinSize && hasValidMaxSize) {
                        const minSize = { width: minSizeMaybe.width, height: minSizeMaybe.height };
                        const maxSize = { width: maxSizeMaybe.width, height: maxSizeMaybe.height };
                        if (minSize.width !== maxSize.width || minSize.height !== maxSize.height) {
                            throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Conflicting size values for SheetSizeBehavior.Exactly');
                        }
                        return { behavior, minSize, maxSize };
                    }
                    if (hasValidMinSize) {
                        const minSize = { width: minSizeMaybe.width, height: minSizeMaybe.height };
                        return { behavior, minSize, maxSize: minSize };
                    }
                    if (hasValidMaxSize) {
                        const maxSize = { width: maxSizeMaybe.width, height: maxSizeMaybe.height };
                        return { behavior, minSize: maxSize, maxSize };
                    }
                }
                throw new TableauError_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSize, 'Invalid sheet size parameter');
            }
            default: {
                throw new TableauError_1.TableauError(Contract.SharedErrorCodes.InternalError, `Unsupported sheet size behavior: ${behavior}`);
            }
        }
    }
}
exports.SheetImpl = SheetImpl;
SheetImpl.parseDimensions = (size) => {
    const empty = { width: undefined, height: undefined };
    if (!size) {
        return empty;
    }
    const { success: widthParsed, parsed: parsedWidth } = Param_1.Param.tryParseNumber(size.width);
    const { success: heightParsed, parsed: parsedHeight } = Param_1.Param.tryParseNumber(size.height);
    if (widthParsed && heightParsed) {
        return { width: parsedWidth, height: parsedHeight };
    }
    if (widthParsed) {
        return { width: parsedWidth };
    }
    if (heightParsed) {
        return { height: parsedHeight };
    }
    return empty;
};
//# sourceMappingURL=SheetImpl.js.map