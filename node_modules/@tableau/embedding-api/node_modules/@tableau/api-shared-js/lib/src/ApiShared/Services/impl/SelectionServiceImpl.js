"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Contract = require("@tableau/api-external-contract-js");
const api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
const SelectionModels_1 = require("../../Models/SelectionModels");
const TableauError_1 = require("../../TableauError");
const Param_1 = require("../../Utils/Param");
const ServiceImplBase_1 = require("./ServiceImplBase");
class SelectionServiceImpl extends ServiceImplBase_1.ServiceImplBase {
    get serviceName() {
        return "selection-service" /* Selection */;
    }
    /**
     * Method to clear all the selected marks for the given worksheet.
     *
     * @param visualId
     */
    clearSelectedMarksAsync(visualId) {
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'clearSelectedMarksAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
        };
        return this.execute(api_internal_contract_js_1.VerbId.ClearSelectedMarks, parameters).then((response) => {
            return; // Expecting an empty model and hence the void response.
        });
    }
    /**
     * Method to select marks for the given worksheet.
     *
     * @param visualId
     * @param selectionCriteria
     * @param selectionUpdateType
     */
    selectMarksByValueAsync(visualId, selectionCriterias, selectionUpdateType) {
        if (selectionCriterias.length === 0) {
            throw new TableauError_1.TableauError(Contract.ErrorCodes.InvalidParameter, 'Selection criteria missing for selecting marks by value');
        }
        const selectionType = this.validateSelectionUpdateType(selectionUpdateType);
        const selectionModelContainer = this.parseSelectionMarks(selectionCriterias);
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'selectMarksByValueAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
            [api_internal_contract_js_1.ParameterId.SelectionUpdateType]: selectionType,
        };
        if (selectionModelContainer.hierModelArr && selectionModelContainer.hierModelArr.length) {
            parameters[api_internal_contract_js_1.ParameterId.HierValSelectionModels] = selectionModelContainer.hierModelArr;
        }
        if (selectionModelContainer.quantModelArr && selectionModelContainer.quantModelArr.length) {
            parameters[api_internal_contract_js_1.ParameterId.QuantRangeSelectionModels] = selectionModelContainer.quantModelArr;
        }
        if (selectionModelContainer.dimModelArr && selectionModelContainer.dimModelArr.length) {
            parameters[api_internal_contract_js_1.ParameterId.DimValSelectionModels] = selectionModelContainer.dimModelArr;
        }
        return this.execute(api_internal_contract_js_1.VerbId.SelectByValue, parameters).then((response) => {
            this.apiFilterHandlerCheckForCommandError(response.result);
            return;
        });
    }
    /**
     * Method to execute hover actions and render tooltip for a given tuple representing a mark in the visualization.
     * If the tooltip parameter is included it will show the tooltip on hover. If not, no tooltip is shown.
     *
     * @param visualId
     * @param hoveredTuple
     * @param tooltip
     * @returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error
     */
    hoverTupleAsync(visualId, hoveredTuple, tooltip, allowHoverActions) {
        let interactionModel = new SelectionModels_1.HoverTupleInteractionModel(visualId, this.ensureTupleIDIsNonNegative(hoveredTuple), tooltip, allowHoverActions);
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'hoverTupleAsync',
            [api_internal_contract_js_1.ParameterId.HoverTupleInteraction]: interactionModel,
        };
        return this.execute(api_internal_contract_js_1.VerbId.RaiseHoverTupleNotification, parameters).then((response) => {
            return;
        });
    }
    /**
     * Method to modify selection, execute select actions and render tooltip for a given list of tuples representing a mark or marks in the visualization.
     * If the tooltip parameter is included it will show the tooltip on select. If not, no tooltip is shown.
     *
     * @param visualId
     * @param selectedTuples
     * @param selectOption
     * @param tooltip
     * @returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error
     */
    selectTuplesAsync(visualId, selectedTuples, selectOption, tooltip) {
        let interactionModel = new SelectionModels_1.SelectTuplesInteractionModel(visualId, selectedTuples, selectOption, tooltip);
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'selectTuplesAsync',
            [api_internal_contract_js_1.ParameterId.SelectTuplesInteraction]: interactionModel,
        };
        return this.execute(api_internal_contract_js_1.VerbId.RaiseSelectTuplesNotification, parameters).then((response) => {
            return;
        });
    }
    apiFilterHandlerCheckForCommandError(serverPm) {
        if (!serverPm[api_internal_contract_js_1.ParameterId.ParameterError]) {
            return;
        }
        if (serverPm[api_internal_contract_js_1.ParameterId.InvalidFields]) {
            throw new TableauError_1.TableauError(Contract.SharedErrorCodes.InvalidSelectionFieldName, serverPm[api_internal_contract_js_1.ParameterId.InvalidFields]);
        }
        if (serverPm[api_internal_contract_js_1.ParameterId.InvalidValues]) {
            throw new TableauError_1.TableauError(Contract.SharedErrorCodes.InvalidSelectionValue, serverPm[api_internal_contract_js_1.ParameterId.InvalidValues]);
        }
        if (serverPm[api_internal_contract_js_1.ParameterId.InvalidDates]) {
            throw new TableauError_1.TableauError(Contract.SharedErrorCodes.InvalidSelectionDate, serverPm[api_internal_contract_js_1.ParameterId.InvalidDates]);
        }
    }
    /**
     * Method to select marks for the given worksheet.
     *
     * @param visualId
     * @param MarkInfo
     * @param selectionUpdateType
     */
    selectMarksByIdAsync(visualId, marks, selectionUpdateType) {
        if (marks.length === 0) {
            throw new TableauError_1.TableauError(Contract.ErrorCodes.InvalidParameter, 'Marks info missing for selecting marks by Id');
        }
        const selectionType = this.validateSelectionUpdateType(selectionUpdateType);
        const selectionModelContainer = this.parseSelectionIds(marks);
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'selectMarksByIdAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
            [api_internal_contract_js_1.ParameterId.SelectionUpdateType]: selectionType,
            [api_internal_contract_js_1.ParameterId.Selection]: selectionModelContainer.selection,
        };
        return this.execute(api_internal_contract_js_1.VerbId.SelectByValue, parameters).then((response) => {
            // Expecting an empty model and hence the void response.
            return;
            // TODO Investigate the error response with multiple output params and throw error accordingly.
        });
    }
    /**
     * Method to prepare the pres models for selection by MarksInfo
     * @param marks
     */
    parseSelectionIds(marks) {
        const ids = [];
        const selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        for (let i = 0; i < marks.length; i++) {
            const tupleId = marks[i].tupleId;
            if (tupleId !== undefined && tupleId !== null) {
                // If tuple id is provided use that instead of pair
                ids.push(tupleId.toString()); // collect the tuple ids
            }
            else {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'tupleId parsing error');
            }
        }
        if (ids.length !== 0) {
            // tuple ids based selection
            const tupleSelectionModel = new SelectionModels_1.TupleSelectionModel();
            tupleSelectionModel.selectionType = 'tuples';
            tupleSelectionModel.objectIds = ids;
            selectionModelContainer.selection = tupleSelectionModel;
        }
        return selectionModelContainer;
    }
    /**
     * Method to prepare the pres models for selection by values.
     *
     * Supports 3 types for selection:
     * 1) Hierarchical value based selection
     * 2) Range value based selection
     * 3) Dimension value based selection
     *
     * @param marks
     */
    parseSelectionMarks(selectionCriterias) {
        const selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        for (let i = 0; i < selectionCriterias.length; i++) {
            const st = selectionCriterias[i];
            if (!(st.fieldName && st.value !== undefined && st.value !== null)) {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'Selection Criteria parsing error');
            }
            const catRegex = new RegExp('([[A-Za-z0-9]+]).*', 'g');
            const rangeOption = st.value;
            if (catRegex.test(st.fieldName)) {
                // Hierarchical value selection
                const hierModel = this.addToParamsList(st.fieldName, st.value);
                selectionModelContainer.hierModelArr.push(hierModel);
            }
            else if (rangeOption.min !== undefined && rangeOption.max !== undefined) {
                // Range value selection
                const quantModel = this.addToRangeParamsList(st.fieldName, rangeOption);
                selectionModelContainer.quantModelArr.push(quantModel);
            }
            else {
                // Dimension value selection
                const dimModel = this.addToParamsList(st.fieldName, st.value);
                selectionModelContainer.dimModelArr.push(dimModel);
            }
        }
        return selectionModelContainer;
    }
    /**
     * Method to transform the key value pair into value based pres model object.
     *
     * @param valueSelectionModel
     * @param fieldName
     * @param value
     */
    addToParamsList(fieldName, value) {
        const valueSelectionModel = new SelectionModels_1.ValueSelectionModel();
        const markValues = [];
        if (value instanceof Array) {
            const valueArr = value;
            for (let i = 0; i < valueArr.length; i++) {
                markValues.push(Param_1.Param.serializeParameterValue(valueArr[i]));
            }
        }
        else {
            markValues.push(Param_1.Param.serializeParameterValue(value));
        }
        valueSelectionModel.qualifiedFieldCaption = fieldName;
        valueSelectionModel.selectValues = markValues;
        return valueSelectionModel;
    }
    /**
     * Method to transform the key value pair into range based selection pres model.
     *
     * TODO: Need to handle the parsing of date type values.
     *
     * @param valueSelectionModel
     * @param fieldName
     * @param value
     */
    addToRangeParamsList(fieldName, value) {
        const rangeSelectionModel = new SelectionModels_1.RangeSelectionModel();
        rangeSelectionModel.qualifiedFieldCaption = fieldName;
        if (value.max !== undefined && value.max !== null) {
            rangeSelectionModel.maxValue = Param_1.Param.serializeParameterValue(value.max);
        }
        if (value.min !== undefined && value.min !== null) {
            rangeSelectionModel.minValue = Param_1.Param.serializeParameterValue(value.min);
        }
        rangeSelectionModel.included = this.validateNullOptionType(value.nullOption);
        return rangeSelectionModel;
    }
    /**
     * Method to validate the selection update type.
     *
     * @param selectionUpdateType
     */
    validateSelectionUpdateType(selectionUpdateType) {
        if (selectionUpdateType === Contract.SelectionUpdateType.Replace) {
            return api_internal_contract_js_1.SelectionUpdateType.Replace;
        }
        else if (selectionUpdateType === Contract.SelectionUpdateType.Add) {
            return api_internal_contract_js_1.SelectionUpdateType.Add;
        }
        else if (selectionUpdateType === Contract.SelectionUpdateType.Remove) {
            return api_internal_contract_js_1.SelectionUpdateType.Remove;
        }
        return api_internal_contract_js_1.SelectionUpdateType.Replace;
    }
    /**
     * Method to validate the include type for range selection.
     *
     * @param nullOption
     */
    validateNullOptionType(nullOption) {
        if (nullOption) {
            if (nullOption === Contract.FilterNullOption.NullValues) {
                return api_internal_contract_js_1.QuantitativeIncludedValues.IncludeNull;
            }
            else if (nullOption === Contract.FilterNullOption.NonNullValues) {
                return api_internal_contract_js_1.QuantitativeIncludedValues.IncludeNonNull;
            }
            else if (nullOption === Contract.FilterNullOption.AllValues) {
                return api_internal_contract_js_1.QuantitativeIncludedValues.IncludeAll;
            }
        }
        return api_internal_contract_js_1.QuantitativeIncludedValues.IncludeAll;
    }
    ensureTupleIDIsNonNegative(tupleId) {
        if (tupleId && tupleId > 0) {
            return tupleId;
        }
        // 0 will not refer to a valid tuple (since tuple ids are 1-based),
        // but can be used for clearing the current hover or selection
        return 0;
    }
}
exports.SelectionServiceImpl = SelectionServiceImpl;
//# sourceMappingURL=SelectionServiceImpl.js.map