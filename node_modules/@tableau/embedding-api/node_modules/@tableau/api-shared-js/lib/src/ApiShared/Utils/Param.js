"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_external_contract_js_1 = require("@tableau/api-external-contract-js");
const TableauError_1 = require("../TableauError");
const ErrorHelpers_1 = require("./ErrorHelpers");
class Param {
    /**
     * serializes the date into the format that the server expects.
     * @param date the date to serialize
     */
    static serializeDateForPlatform(date) {
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();
        const hh = date.getUTCHours();
        const mm = date.getUTCMinutes();
        const sec = date.getUTCSeconds();
        return `${year}-${month}-${day} ${hh}:${mm}:${sec}`;
    }
    static serializeBooleanForPlatform(bool) {
        return bool ? 'true' : 'false';
    }
    static serializeNumberForPlatform(num) {
        return num.toString(10);
    }
    /**
     * Verifies the input is a number
     */
    /* tslint:disable-next-line:no-any */
    static isTypeNumber(input) {
        return typeof input === 'number' || input instanceof Number;
    }
    /**
     * Verifies the input is a Date
     */
    /* tslint:disable-next-line:no-any */
    static isTypeDate(input) {
        return input instanceof Date;
    }
    /* tslint:disable-next-line:no-any */
    static isTypeString(input) {
        return typeof input === 'string' || input instanceof String;
    }
    /* tslint:disable-next-line:no-any */
    static isTypeBool(input) {
        return typeof input === 'boolean' || input instanceof Boolean;
    }
    /**
     * Determines if the input is null or undefined
     */
    /* tslint:disable-next-line:no-any */
    static isNullOrUndefined(input) {
        return input === null || input === undefined;
    }
    /* tslint:disable-next-line:no-any */
    static serializeParameterValue(value) {
        if (Param.isTypeNumber(value)) {
            return Param.serializeNumberForPlatform(value);
        }
        else if (Param.isTypeDate(value)) {
            return Param.serializeDateForPlatform(value);
        }
        else if (Param.isTypeBool(value)) {
            return Param.serializeBooleanForPlatform(value);
        }
        else if (Param.isTypeString(value)) {
            return value;
        }
        else {
            throw new TableauError_1.TableauError(api_external_contract_js_1.ErrorCodes.InternalError, `Unexpected invalid value for: ${value}`);
        }
    }
    /**
     * Verifies that the parameter is already a Map, or converts an object to a Map.
     * If the parameter is an object, we convert it to a Map using Object.entries.
     * @throws if the parameter is not an object or Map
     */
    // tslint:disable-next-line:no-any
    static convertParameterToMap(param, paramName) {
        ErrorHelpers_1.ErrorHelpers.verifyParameterType(param, 'object', paramName);
        if (Array.isArray(param)) {
            throw new TableauError_1.TableauError(api_external_contract_js_1.ErrorCodes.InvalidParameter, `Expecting object or Map for: ${paramName}.`);
        }
        return param instanceof Map ? param : new Map(Object.entries(param));
    }
    /* tslint:disable-next-line:no-any */
    static tryParseNumber(value) {
        if (Param.isNullOrUndefined(value)) {
            return { success: false };
        }
        if (Param.isTypeNumber(value)) {
            return { parsed: value, success: true };
        }
        const valueString = value.toString();
        if (valueString === 'NaN') {
            // 'NaN' parses as NaN which is indistinguishable from a failed parse.
            return { parsed: NaN, success: true };
        }
        const parsed = parseFloat(valueString);
        if (isNaN(parsed)) {
            return { success: false };
        }
        return { parsed, success: true };
    }
}
exports.Param = Param;
//# sourceMappingURL=Param.js.map