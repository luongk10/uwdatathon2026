"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
const api_external_contract_js_1 = require("@tableau/api-external-contract-js");
const ExternalToInternalEnumMappings_1 = require("../../EnumMappings/ExternalToInternalEnumMappings");
const ExportHelpers_1 = require("../../Utils/ExportHelpers");
const ErrorHelpers_1 = require("../../Utils/ErrorHelpers");
const TableauError_1 = require("../../TableauError");
const ServiceImplBase_1 = require("./ServiceImplBase");
class ExportServiceImpl extends ServiceImplBase_1.ServiceImplBase {
    get serviceName() {
        return "export-service" /* Export */;
    }
    getExportCrosstabSheetMapAsync(currentSheetType) {
        const verb = api_internal_contract_js_1.VerbId.GetExportCrosstabSheetMap;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getExportCrosstabSheetMapAsync',
            [api_internal_contract_js_1.ParameterId.CurrentSheetType]: ExternalToInternalEnumMappings_1.ExternalToInternalEnumMappings.sheetType.convert(currentSheetType),
        };
        return this.execute(verb, parameters).then((response) => {
            const result = response.result;
            return result;
        });
    }
    exportCrosstabAsync(sheetName, format, exportableWorksheetNames, currentSheetType) {
        return __awaiter(this, void 0, void 0, function* () {
            ErrorHelpers_1.ErrorHelpers.verifySheetName(exportableWorksheetNames, sheetName);
            ErrorHelpers_1.ErrorHelpers.verifyEnumValue(format, api_external_contract_js_1.CrosstabFileFormat, 'CrosstabFileFormat');
            // The pres layer command for exporting Crosstab uses SimpleSheetIdentifiers instead of sheet names.
            // The extensions-and-embedding-api current does not store references to the SimpleSheetIdentifiers of its sheets
            // so we call a pres layer command that gives us the SimpleSheetIdentifier for each sheet name that appears in the
            // export Crosstab dialog popup.
            const sheetNameToIdMap = yield this.getExportCrosstabSheetMapAsync(currentSheetType);
            if (!sheetNameToIdMap[sheetName]) {
                throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InternalError, 'missing sheet doc id from sheetMap');
            }
            const parameters = {
                [api_internal_contract_js_1.ParameterId.FunctionName]: 'exportCrosstabAsync',
                [api_internal_contract_js_1.ParameterId.SheetIdentifier]: sheetNameToIdMap[sheetName],
                [api_internal_contract_js_1.ParameterId.SendNotifications]: true,
            };
            // pres layer command invoked depends on the crosstab file format
            let verb;
            switch (format) {
                case api_external_contract_js_1.CrosstabFileFormat.CSV:
                    verb = api_internal_contract_js_1.VerbId.ExportCrosstabCsvDownload;
                    // CSV only parameter: see browser-clients/export-crosstab-options-dialog repo
                    parameters[api_internal_contract_js_1.ParameterId.UseTabDelimiters] = true;
                    break;
                case api_external_contract_js_1.CrosstabFileFormat.Excel:
                    verb = api_internal_contract_js_1.VerbId.ExportCrosstabExcelDownload;
                    break;
                default:
                    throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.InternalError, 'unsupported Crosstab file format.');
            }
            return this.execute(verb, parameters)
                .then((response) => {
                const result = response.result;
                return result;
            })
                .catch(() => {
                throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.CrosstabCreationError, 'An unexpected error occurred while generating the document.');
            });
        });
    }
    exportDataAsync(visualId, options) {
        var _a;
        ErrorHelpers_1.ErrorHelpers.verifyExportDataOptions(options);
        // Remove any duplicates from the input array
        const columnsAsSet = new Set(options.columnsToIncludeById);
        const columnsToIncludeById = Array.from(columnsAsSet);
        const verb = api_internal_contract_js_1.VerbId.ExportDataDownload;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'exportDataAsync',
            [api_internal_contract_js_1.ParameterId.VisualId]: visualId,
            [api_internal_contract_js_1.ParameterId.IgnoreAliases]: (_a = options.ignoreAliases, (_a !== null && _a !== void 0 ? _a : false)),
            [api_internal_contract_js_1.ParameterId.ColumnsToIncludeById]: columnsToIncludeById,
        };
        return this.execute(verb, parameters)
            .then(() => { })
            .catch(() => {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.DataCreationError, 'An unexpected error occurred while generating the document.');
        });
    }
    exportPowerPointAsync(sheetNames, exportScenarios) {
        ErrorHelpers_1.ErrorHelpers.verifySheetNamesForPDFAndPPT(sheetNames, exportScenarios);
        // Note: the ExportOriginUrl param is listed as optional for the pres layer command we are invoking; however,
        // recent changes were made that enforced the use of the empty string when invoking this command with no ExportOriginUrl.
        // see browser-clients/export-powerpoint-options-dialog repo.
        const verb = api_internal_contract_js_1.VerbId.ExportPowerpointDownload;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'exportPowerPointAsync',
            [api_internal_contract_js_1.ParameterId.ExportOriginUrl]: '',
            [api_internal_contract_js_1.ParameterId.SelectedSheetNames]: sheetNames,
        };
        return this.execute(verb, parameters)
            .then((response) => {
            const result = response.result;
            return result;
        })
            .catch(() => {
            throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.PowerPointCreationError, 'An error occured while attempting to generate the PowerPoint file.');
        });
    }
    exportPDFAsync(sheetNames, externalExportPdfOptions, exportScenarios) {
        return __awaiter(this, void 0, void 0, function* () {
            ErrorHelpers_1.ErrorHelpers.verifyExportPDFOptions(externalExportPdfOptions);
            ErrorHelpers_1.ErrorHelpers.verifySheetNamesForPDFAndPPT(sheetNames, exportScenarios);
            const internalExportPdfOptions = yield this.getExportPDFOptionsAsync();
            ExportHelpers_1.ExportHelpers.updateInternalExportPDFOptions(internalExportPdfOptions, externalExportPdfOptions, sheetNames);
            const verb = api_internal_contract_js_1.VerbId.ExportPdfDownload;
            const parameters = {
                [api_internal_contract_js_1.ParameterId.FunctionName]: 'exportPDFAsync',
                [api_internal_contract_js_1.ParameterId.ExportPdfOptions]: internalExportPdfOptions,
            };
            return this.execute(verb, parameters)
                .then((response) => {
                const result = response.result;
                return result;
            })
                .catch(() => {
                throw new TableauError_1.TableauError(api_external_contract_js_1.SharedErrorCodes.PDFCreationError, 'Unable to create PDF because something went wrong. Try again.');
            });
        });
    }
    getExportPDFOptionsAsync() {
        const verb = api_internal_contract_js_1.VerbId.GetExportPdfOptions;
        const parameters = {
            [api_internal_contract_js_1.ParameterId.FunctionName]: 'getExportPdfOptionsAsync',
        };
        return this.execute(verb, parameters).then((response) => {
            const result = response.result;
            return result;
        });
    }
}
exports.ExportServiceImpl = ExportServiceImpl;
//# sourceMappingURL=ExportServiceImpl.js.map