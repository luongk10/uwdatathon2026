"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Contract = require("@tableau/api-external-contract-js");
const TableauError_1 = require("../TableauError");
const Deferred_1 = require("./Deferred");
/**
 * A Deferred wrapper class adding functionality to reject unresponsive promises after timeout
 *
 * this class handles two things:

 *    1. Adds timeout logic for deferred
 *    2. It blocks multiple calls from executing at the same time.
 *
 * @export
 * @class ShortLivedDeferred
 * @template TResolve The type used to resolve the promise.
 * @template TReject The type used to reject the promise. Defaults to any.
 *
 */
class ShortLivedDeferred {
    constructor(_timeoutInMilliseconds = Deferred_1.UnregisterTimeoutInMilliseconds) {
        this._timeoutInMilliseconds = _timeoutInMilliseconds;
    }
    getNewPromiseOrThrowIfBusy() {
        if (this._deferred) {
            throw new TableauError_1.TableauError(Contract.SharedErrorCodes.ApiExecutionError, 'This api cannot be executed till previous call is resolved.');
        }
        this._deferred = new Deferred_1.Deferred();
        this._timeoutId = setTimeout(() => {
            const error = new TableauError_1.TableauError(Contract.SharedErrorCodes.Timeout, `Api failed to complete in ${this._timeoutInMilliseconds / 1000} seconds`);
            this.reject(error);
        }, this._timeoutInMilliseconds);
        return this._deferred.promise;
    }
    resolve(response) {
        if (this._deferred) {
            clearTimeout(this._timeoutId);
            this._deferred.resolve(response);
            this._deferred = undefined;
        }
    }
    reject(error) {
        if (this._deferred) {
            clearTimeout(this._timeoutId);
            this._deferred.reject(error);
            this._deferred = undefined;
        }
    }
}
exports.ShortLivedDeferred = ShortLivedDeferred;
//# sourceMappingURL=ShortLivedDeferred.js.map