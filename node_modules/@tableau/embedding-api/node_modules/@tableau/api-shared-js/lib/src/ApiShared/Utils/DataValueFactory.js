"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InternalContract = require("@tableau/api-internal-contract-js");
const GetDataModels_1 = require("../Models/GetDataModels");
/**
 * In version 2 of the interface, we should collapse value into nativeValue, and do all this work over
 * in the platform.
 */
class DataValueFactory {
    static MakeParameterDataValue(internalDataValue, dataType) {
        // Parameter values are all strings, convert from string to value
        return new GetDataModels_1.DataValue(internalDataValue.value, InternalContract.DataTypeConverter.convertStringValueToNativeValue(internalDataValue.value, dataType), internalDataValue.formattedValue, internalDataValue.aliasedValue, internalDataValue.hasAlias);
    }
    static MakeFilterDataValue(internalDataValue) {
        // Filters already have native type in value, just use that for nativeValue also
        return new GetDataModels_1.DataValue(internalDataValue.value, internalDataValue.value, internalDataValue.formattedValue);
    }
    static MakeTableDataValue(internalDataValue, dataType) {
        // DataTables contain boolean | number | string | date as string | '%null%
        // convertValueToNativeValue converts dates as string to dates, and any special to null
        // (boolean, numbers, strings are passed through)
        // Because of IncludeDataValuesOption - we can have undefined values, which are different than any special
        return new GetDataModels_1.DataValue(internalDataValue.value, internalDataValue.value !== undefined
            ? InternalContract.DataTypeConverter.convertValueToNativeValue(internalDataValue.value, dataType)
            : undefined, internalDataValue.formattedValue);
    }
}
exports.DataValueFactory = DataValueFactory;
//# sourceMappingURL=DataValueFactory.js.map