"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const VersionConverterFactory_1 = require("../VersionConverterFactory");
const ExternalIdentityVersionConverter_1 = require("./ExternalIdentityVersionConverter");
const ExternalStackingVersionConverter_1 = require("./ExternalStackingVersionConverter");
// A mapping from the current client version of internal-contract to an older platform version of the contract.
// Each version bump can have an array of translations to perform in order.
// These translations handle downgradeExecuteCall and upgradeExecuteReturn and are meant to be called on the
// client/external side.
// When updating the major or minor version of our internal-contract, you will need to update these data structures.
// * If there are translations to add, add them to the version to 'upgrade from' or 'downgrade to'.
exports.ExecuteMinorDowngradeCallExternal = {
    1: {
        9: [],
    },
};
exports.ExecuteMinorUpgradeReturnExternal = {
    1: {
        9: [],
    },
};
exports.ExecuteMinorUpgradeNotification = {
    1: {
        9: [],
    },
};
/**
 * Creates a new ExternalContractVersionConverter which has the ability to upgrade and downgrade
 * the contract between the two versions which are specified. If externalMajorVersion is less than
 * platformMajorVersion, an ExternalIdentityVersionConverter will be returned.
 * Handles upgrade/downgrade for both major and minor updates.
 *
 * @param externalVersion VersionNumber of the internal api which the external module is using
 * @param platformVersion VersionNumber of the internal api which the platform is using
 */
function CreateExternalCompatibleVersionConverter(externalVersion, platformVersion) {
    return CreateExternalCompatibleVersionConverterWithTranslators(externalVersion, platformVersion, exports.ExecuteMinorDowngradeCallExternal, exports.ExecuteMinorUpgradeReturnExternal, exports.ExecuteMinorUpgradeNotification);
}
exports.CreateExternalCompatibleVersionConverter = CreateExternalCompatibleVersionConverter;
/**
 * Implementation of CreateExternalCompatibleVersionConverterWithTranslators.
 * This function takes the upgrade, downgrade arrays so that all the logic can be tested.
 *
 * @param externalVersion VersionNumber of the internal contract which the external module is using
 * @param platformVersion VersionNumber of the internal contract which the platform is using
 * @param upgrades MajorMinorTranslators for response upgrades
 * @param downgrades MajorMinorTranslators for execute call downgrades
 */
function CreateExternalCompatibleVersionConverterWithTranslators(externalVersion, platformVersion, downgrades, upgrades, upgradeNotifications) {
    const externalMajorVersion = externalVersion.major;
    const platformMajorVersion = platformVersion.major;
    const platformMinorVersion = platformVersion.minor;
    // This check is present in VersionConverterFactory. We throw the same error here as well.
    // Hence we only need to check the minor versions for translations.
    if (externalMajorVersion > platformMajorVersion) {
        throw new Error(`External version must be less than or equal to platform version.
    externalMajorVersion=${externalMajorVersion} platformMajorVersion=${platformMajorVersion}`);
    }
    if (externalMajorVersion < platformMajorVersion || VersionConverterFactory_1.VersionEqualTo(externalVersion, platformVersion)) {
        return new ExternalIdentityVersionConverter_1.ExternalIdentityVersionConverter();
    }
    // Walk the span between the versions we have here and collect the upgrade and downgrades necessary
    const neededExecuteCallDowngrade = GetNeededExternalTranslations(platformMajorVersion, platformMinorVersion, downgrades);
    const neededExecuteReturnUpgrades = GetNeededExternalTranslations(platformMajorVersion, platformMinorVersion, upgrades);
    const neededNotificationUpgrades = GetNeededExternalTranslations(platformMajorVersion, platformMinorVersion, upgradeNotifications);
    // Reverse the downgrade calls, so that we start the downgrade from the external version to the platform version
    neededExecuteCallDowngrade.reverse();
    return new ExternalStackingVersionConverter_1.ExternalStackingVersionConverter(externalVersion, platformVersion, neededExecuteCallDowngrade, neededExecuteReturnUpgrades, neededNotificationUpgrades);
}
exports.CreateExternalCompatibleVersionConverterWithTranslators = CreateExternalCompatibleVersionConverterWithTranslators;
function GetNeededExternalTranslations(platformMajorVersion, platformMinorVersion, majorMinorTranslators) {
    const neededTranslations = [];
    if (platformMajorVersion in majorMinorTranslators) {
        const start = platformMinorVersion;
        const maximumMinorVersion = VersionConverterFactory_1.GetMaximumMinorIndex(Object.keys(majorMinorTranslators[platformMajorVersion]));
        for (let minor = start; minor <= maximumMinorVersion; minor++) {
            if (minor in majorMinorTranslators[platformMajorVersion]) {
                neededTranslations.push(...majorMinorTranslators[platformMajorVersion][minor]);
            }
        }
    }
    return neededTranslations;
}
//# sourceMappingURL=ExternalVersionConverterFactory.js.map