"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const guid = require("guid");
const JsApiInternalContract_1 = require("../JsApiInternalContract");
const CrossFramePreparedMessage_1 = require("./CrossFramePreparedMessage");
const MessageTypeChecks_1 = require("./MessageTypeChecks");
const MessageTypes_1 = require("./interface/MessageTypes");
/**
 * The CrossFrameMessenger is the primary export from the api-messaging module. An instance of
 * this class can be instantiated on both sides of a frame boundary to facilitate communication
 * in both directions between the frames. This class implements both the dispatcher and the listener
 * portions, but doesn't require callers to care about both.
 */
class CrossFrameMessenger {
    /**
     * Creates an instance of CrossFrameMessenger. If you would like to use the CrossFrameMessenger as a MessageListener,
     * be sure to call StartListening and register message handlers.
     * @param thisWindow The window object which the CrossFrameMessenger lives. An onMessage listener will be added here.
     * @param [otherWindow] Optional otherWindow which messages will be posted to.
     *                      If defined, incoming messages must originate from otherWindow to be passed on
     * @param [otherWindowOrigin] The target origin which otherWindow must have in order to receive dispatched messages.
     *                            This value will be sent as the targetOrigin of a postMessage
     *                            (https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)
     */
    constructor(thisWindow, otherWindow, otherWindowOrigin) {
        this.thisWindow = thisWindow;
        this.otherWindow = otherWindow;
        this.otherWindowOrigin = otherWindowOrigin;
        // Make sure to call StartListening
    }
    ///// MessageListener Implementation
    startListening() {
        // Check if we already are listening, if not, hook up a message listener
        if (!this.unregisterFunction) {
            const boundHandler = this.onMessageReceived.bind(this);
            this.thisWindow.addEventListener('message', boundHandler, true);
            this.unregisterFunction = () => this.thisWindow.removeEventListener('message', boundHandler, true);
        }
    }
    stopListening() {
        // Stop listening if we have started listening
        if (this.unregisterFunction) {
            this.unregisterFunction();
            this.unregisterFunction = undefined;
        }
    }
    setInitializeMessageHandler(handler) {
        this.initializeMessageHandler = handler;
    }
    setCommandResponseMessageHandler(handler) {
        this.commandResponseMessageHandler = handler;
    }
    setCommandMessageHandler(handler) {
        this.commandMessageHandler = handler;
    }
    setNotificationMessageHandler(handler) {
        this.notificationMessageHandler = handler;
    }
    setHandshakeMessageHandler(handler) {
        this.handshakeMessageHandler = handler;
    }
    ///// MessageDispatcher Implementation
    /**
     * @param apiVersion api-internal-contract-js version (exported in JsApiInternalConntract)
     * @param crossFrameVersion crossframe messaging version (exported in JsApiInternalConntract)
     * @param options additional options that can be passed at initialization (information about the version of
     *                external being used for example)
     */
    prepareInitializationMessage(apiVersion, crossFrameVersion, options) {
        const message = {
            msgGuid: guid.raw(),
            msgType: MessageTypes_1.MessageType.Initialize,
            crossFrameVersion: crossFrameVersion,
            apiVersion: apiVersion,
            options: options,
        };
        return this.prepareMessage(message);
    }
    prepareCommandMessage(verbId, parameters) {
        const message = {
            msgGuid: guid.raw(),
            msgType: MessageTypes_1.MessageType.Command,
            verbId: verbId,
            parameters: parameters,
        };
        return this.prepareMessage(message);
    }
    prepareCommandResponseMessage(commandGuid, data, error) {
        const message = {
            msgGuid: guid.raw(),
            msgType: MessageTypes_1.MessageType.CommandResponse,
            commandGuid: commandGuid,
            data: data,
            error: error,
        };
        if (error) {
            // stringify error object to remove unserializable fields like functions and prevent serialization errors
            message.error = JSON.parse(JSON.stringify(error));
        }
        return this.prepareMessage(message);
    }
    prepareNotificationMessage(notificationId, data) {
        const message = {
            msgGuid: guid.raw(),
            msgType: MessageTypes_1.MessageType.Notification,
            notificationId: notificationId,
            data: data,
        };
        return this.prepareMessage(message);
    }
    prepareAckMessage() {
        const message = {
            msgGuid: guid.raw(),
            msgType: MessageTypes_1.MessageType.Ack,
            platformVersion: JsApiInternalContract_1.INTERNAL_CONTRACT_VERSION,
        };
        return this.prepareMessage(message);
    }
    /**
     * Prepares a pending message for sending and returns the prepared message
     *
     * @param msg The message to be sent to this.otherWindow
     * @returns The prepared message
     */
    prepareMessage(msg) {
        if (!this.otherWindow || !this.otherWindowOrigin) {
            throw 'Other window not initialized, cannot dispatch messages';
        }
        const preparedMessage = new CrossFramePreparedMessage_1.CrossFramePreparedMessage(msg, this.otherWindow, this.otherWindowOrigin);
        return preparedMessage;
    }
    /**
     * Called when a message is received. Does some validation of the message, and then
     * calls an appropriate message handler if one is defined
     *
     * @param event The incoming MessageEvent
     */
    onMessageReceived(event) {
        // If we have an otherWindow defined, make sure the message is coming from there
        if (this.otherWindow && event.source !== this.otherWindow) {
            return;
        }
        // Do some validation on event.data to make sure that we have received a real message
        if (!event.data) {
            return;
        }
        const message = event.data;
        if (!MessageTypeChecks_1.isMessage(message)) {
            return;
        }
        // Check the declared message type, validate the message, and call an appropriate hander if one exists
        switch (message.msgType) {
            case MessageTypes_1.MessageType.Initialize: {
                if (!MessageTypeChecks_1.isInitMessage(message) || !this.initializeMessageHandler) {
                    return;
                }
                this.initializeMessageHandler(message, event.source);
                break;
            }
            case MessageTypes_1.MessageType.CommandResponse: {
                if (!MessageTypeChecks_1.isCommandResponseMessage(message) || !this.commandResponseMessageHandler) {
                    return;
                }
                this.commandResponseMessageHandler(message, event.source);
                break;
            }
            case MessageTypes_1.MessageType.Command: {
                if (!MessageTypeChecks_1.isCommandMessage(message) || !this.commandMessageHandler) {
                    return;
                }
                this.commandMessageHandler(message, event.source);
                break;
            }
            case MessageTypes_1.MessageType.Notification: {
                if (!MessageTypeChecks_1.isNotificationMessage(message) || !this.notificationMessageHandler) {
                    return;
                }
                this.notificationMessageHandler(message, event.source);
                break;
            }
            case MessageTypes_1.MessageType.Handshake: {
                if (!MessageTypeChecks_1.isHandshakeMessage(message) || !this.handshakeMessageHandler) {
                    return;
                }
                this.handshakeMessageHandler(message, event.source);
                break;
            }
            default:
            // Just ignore this since we don't know how to handle the message type
        }
    }
    setOtherWindow(otherWindow) {
        this.otherWindow = otherWindow;
    }
    setOtherWindowOrigin(origin) {
        this.otherWindowOrigin = origin;
    }
}
exports.CrossFrameMessenger = CrossFrameMessenger;
//# sourceMappingURL=CrossFrameMessenger.js.map